# 基准策略文档：AI 评分模型 (Benchmark 3: AI Scoring)

**版本**: 1.0
**日期**: 2025-11-25
**模块**: `BacktestEngine`
**依赖**: `MarketContext` (VIX Data)

## 1. 核心理念

该基准模拟了一个**基于多因子打分的择时策略**。它不再是盲目地买入或持有，而是每天根据市场状态计算一个 **“AI 抄底分 (AI Score)”**。

*   **分数越高**：代表市场越恐慌、折扣越大 -> **买入/持有**。
*   **分数越低**：代表市场越贪婪、风险越高 -> **卖出/空仓**。

## 2. 评分规则表 (Scoring Rules)

我们选取三个最核心的维度：**宏观情绪 (VIX)**、**技术面 (RSI)**、**价格形态 (回撤)**。总分范围 0 - 6 分。

| 维度 | 指标 | 条件 | 得分 | 逻辑解读 |
| :--- | :--- | :--- | :--- | :--- |
| **宏观情绪** | **VIX** (恐慌指数) | > 20 | **+1** | 市场开始不安 |
| | | > 30 | **+1** (累加) | 市场极度恐慌 (黄金坑) |
| **技术指标** | **RSI** (14日) | < 40 | **+1** | 进入弱势区 |
| | | < 30 | **+1** (累加) | 进入超卖区 (反弹在即) |
| **价格形态** | **回撤** (Drawdown) | < -5% | **+1** | 小幅回调 |
| | | < -15% | **+1** (累加) | 深度打折 |

## 3. 交易执行逻辑

这是一个 **全仓切换 (All-in / All-out)** 模型，为了与“买入并持有”进行直观对比。

*   **初始状态**：100% 现金。
*   **每日评分**：计算当日总分。
*   **买入信号 (Entry)**：
    *   当 `Total Score >= 2` **且** 当前为空仓 -> **全仓买入**。
    *   *逻辑：只要稍微有一点恐慌或折扣（满足任意两个初级条件，或一个极端条件），就开始建仓。*
*   **卖出信号 (Exit)**：
    *   当 `RSI > 70` (超买) **或** `Drawdown > -2%` (接近新高) **且** 当前持有仓位 -> **清仓止盈**。
    *   *逻辑：当市场情绪过热，或者价格已经完全修复回到高点附近时，落袋为安，等待下一次机会。*

---

## 4. 代码实现

请将此逻辑集成到 `BacktestEngine` 类中。

### 4.1 辅助：内置指标计算

为了保持基准的独立性，我们在基准方法内部快速计算所需的 RSI 和回撤，不依赖策略配置。

```typescript
	/**
	 * 计算基准3：AI 评分模型 (AI Score Model)
	 * 一个基于 VIX、RSI 和 回撤 的简单多因子择时策略
	 */
	private calculateAIScoreBenchmark(
		data: ETFDataPoint[],
		dates: string[],
		initialCapital: number,
		vixMap?: Map<string, number>
	): { equityCurve: number[], stats: PerformanceMetrics } {

		let cash = initialCapital;
		let positions = 0;
		const equityCurve: number[] = [];
		let runningMax = -Infinity;

		// 简单的 RSI 计算状态
		const rsiPeriod = 14;
		let gains: number[] = [];
		let losses: number[] = [];

		for (let i = 0; i < data.length; i++) {
			const point = data[i];
			const price = point.c;
			const date = point.d;

			// --- 1. 更新指标数据 ---

			// A. 更新回撤
			if (price > runningMax) runningMax = price;
			const drawdown = ((price - runningMax) / runningMax) * 100;

			// B. 更新 RSI (简单版 SMA 算法)
			let rsi = 50; // 默认中性
			if (i > 0) {
				const change = price - data[i - 1].c;
				gains.push(change > 0 ? change : 0);
				losses.push(change < 0 ? Math.abs(change) : 0);

				// 保持窗口大小
				if (gains.length > rsiPeriod) {
					gains.shift();
					losses.shift();
				}

				if (i >= rsiPeriod) {
					const avgGain = gains.reduce((a, b) => a + b, 0) / rsiPeriod;
					const avgLoss = losses.reduce((a, b) => a + b, 0) / rsiPeriod;
					if (avgLoss === 0) rsi = 100;
					else rsi = 100 - (100 / (1 + avgGain / avgLoss));
				}
			}

			// C. 获取 VIX
			const vix = vixMap?.get(date) || 0;

			// --- 2. 计算 AI 分数 (Rule-based Scoring) ---
			let score = 0;

			// 因子1: 恐慌指数
			if (vix > 20) score += 1;
			if (vix > 30) score += 1; // 叠加

			// 因子2: RSI 超卖
			if (rsi < 40) score += 1;
			if (rsi < 30) score += 1; // 叠加

			// 因子3: 回撤深度
			if (drawdown < -5) score += 1;
			if (drawdown < -15) score += 1; // 叠加

			// --- 3. 执行交易决策 ---

			const isInvested = positions > 0;

			if (!isInvested) {
				// 买入信号: 分数 >= 2 (只要有两个维度的轻度信号，或一个维度的重度信号)
				if (score >= 2) {
					const quantity = cash / price;
					positions = quantity;
					cash = 0;
				}
			} else {
				// 卖出信号:
				// 1. RSI 超买 (>70) -> 即使没创新高也卖
				// 2. 价格修复 (回撤 > -2%) -> 接近前高，获利了结
				// 3. 保护性止损 (可选，暂不加，保持基准简单)
				if (rsi > 70 || drawdown > -2) {
					cash = positions * price;
					positions = 0;
				}
			}

			// --- 4. 记录净值 ---
			const totalValue = cash + (positions * price);
			if (dates.includes(date)) {
				equityCurve.push(totalValue);
			}
		}

		return {
			equityCurve,
			stats: this.calculateMetricsFromCurve(equityCurve, dates)
		};
	}
```

### 4.2 集成到 `runBacktest`

在 `BacktestEngine` 中更新主逻辑：

```typescript
// ... runBacktest 方法内部 ...

// 1. 计算 DCA 基准
const dcaBenchmark = this.calculateWeeklyDCABenchmark(...);

// 2. [新增] 计算 AI Score 基准
const aiBenchmark = this.calculateAIScoreBenchmark(
    filteredData,
    chartData.dates,
    strategy.initialCapital,
    context.vixData // 传入 VIX 数据
);

return {
    // ...
    performance: {
        strategy: performance.strategy,
        benchmark: performance.benchmark, // 买入持有
        dca: dcaBenchmark.stats,          // 周定投
        aiScore: aiBenchmark.stats        // [新增] AI 评分
    },
    charts: {
        // ...
        dcaEquity: dcaBenchmark.equityCurve,
        aiScoreEquity: aiBenchmark.equityCurve, // [新增]
    }
    // ...
};
```

同时，记得更新 `api-dtos.ts` 中的类型定义，增加 `aiScore` 和 `aiScoreEquity` 字段。

---

## 5. 前端展示建议

*   **名称**：**AI 评分模型 (AI Score)**
*   **颜色**：<span style="color:#8B5CF6">**紫色 (Purple)**</span> - 代表智慧、科技。
*   **图表行为预期**：
    *   **买入持有**：一条跟随价格起伏的线。
    *   **AI 评分**：一条**阶梯状**的线。
        *   在牛市主升浪（RSI 高、回撤小）时，它可能是平的（空仓，持有现金）。
        *   在暴跌或回调时，它会突然进场抄底。
        *   反弹后，它会获利离场，净值锁定在高位。

*   **对比价值**：
    *   如果在**震荡市**，AI 评分模型通常会完胜“买入持有”（高抛低吸）。
    *   如果在**单边大牛市**，AI 评分模型可能会跑输（因为它可能卖飞了）。

这能非常直观地教育用户：**“完美的择时是不存在的，每种策略都有适应的市场环境。”**
