# 基准策略文档：AI 评分模型 (Benchmark 3: AI Scoring)

**版本**: 1.0
**日期**: 2025-11-25
**模块**: `BacktestEngine`
**依赖**: `MarketContext` (VIX Data)

## 1. 核心理念

该基准模拟了一个**基于多因子打分的择时策略**。它不再是盲目地买入或持有，而是每天根据市场状态计算一个 **“AI 抄底分 (AI Score)”**。

*   **分数越高**：代表市场越恐慌、折扣越大 -> **买入/持有**。
*   **分数越低**：代表市场越贪婪、风险越高 -> **卖出/空仓**。

## 2. 评分规则表 (Scoring Rules)

我们选取三个最核心的维度：**宏观情绪 (VIX)**、**技术面 (RSI)**、**价格形态 (回撤)**。总分范围 0 - 6 分。

| 维度 | 指标 | 条件 | 得分 | 逻辑解读 |
| :--- | :--- | :--- | :--- | :--- |
| **宏观情绪** | **VIX** (恐慌指数) | > 20 | **+1** | 市场开始不安 |
| | | > 30 | **+1** (累加) | 市场极度恐慌 (黄金坑) |
| **技术指标** | **RSI** (14日) | < 40 | **+1** | 进入弱势区 |
| | | < 30 | **+1** (累加) | 进入超卖区 (反弹在即) |
| **价格形态** | **回撤** (Drawdown) | < -5% | **+1** | 小幅回调 |
| | | < -15% | **+1** (累加) | 深度打折 |

## 3. 交易执行逻辑

这是一个 **全仓切换 (All-in / All-out)** 模型，为了与“买入并持有”进行直观对比。

*   **初始状态**：100% 现金。
*   **每日评分**：计算当日总分。
*   **买入信号 (Entry)**：
    *   当 `Total Score >= 2` **且** 当前为空仓 -> **全仓买入**。
    *   *逻辑：只要稍微有一点恐慌或折扣（满足任意两个初级条件，或一个极端条件），就开始建仓。*
*   **卖出信号 (Exit)**：
    *   当 `RSI > 70` (超买) **或** `Drawdown > -2%` (接近新高) **且** 当前持有仓位 -> **清仓止盈**。
    *   *逻辑：当市场情绪过热，或者价格已经完全修复回到高点附近时，落袋为安，等待下一次机会。*

---

## 4. 代码实现

请将此逻辑集成到 `BacktestEngine` 类中。

### 4.1 辅助：内置指标计算

为了保持基准的独立性，我们在基准方法内部快速计算所需的 RSI 和回撤，不依赖策略配置。

```typescript
	/**
	 * 计算基准3：AI 评分模型 (AI Score Model)
	 * 一个基于 VIX、RSI 和 回撤 的简单多因子择时策略
	 */
	private calculateAIScoreBenchmark(
		data: ETFDataPoint[],
		dates: string[],
		initialCapital: number,
		vixMap?: Map<string, number>
	): { equityCurve: number[], stats: PerformanceMetrics } {

		let cash = initialCapital;
		let positions = 0;
		const equityCurve: number[] = [];
		let runningMax = -Infinity;

		// 简单的 RSI 计算状态
		const rsiPeriod = 14;
		let gains: number[] = [];
		let losses: number[] = [];

		for (let i = 0; i < data.length; i++) {
			const point = data[i];
			const price = point.c;
			const date = point.d;

			// --- 1. 更新指标数据 ---

			// A. 更新回撤
			if (price > runningMax) runningMax = price;
			const drawdown = ((price - runningMax) / runningMax) * 100;

			// B. 更新 RSI (简单版 SMA 算法)
			let rsi = 50; // 默认中性
			if (i > 0) {
				const change = price - data[i - 1].c;
				gains.push(change > 0 ? change : 0);
				losses.push(change < 0 ? Math.abs(change) : 0);

				// 保持窗口大小
				if (gains.length > rsiPeriod) {
					gains.shift();
					losses.shift();
				}

				if (i >= rsiPeriod) {
					const avgGain = gains.reduce((a, b) => a + b, 0) / rsiPeriod;
					const avgLoss = losses.reduce((a, b) => a + b, 0) / rsiPeriod;
					if (avgLoss === 0) rsi = 100;
					else rsi = 100 - (100 / (1 + avgGain / avgLoss));
				}
			}

			// C. 获取 VIX
			const vix = vixMap?.get(date) || 0;

			// --- 2. 计算 AI 分数 (Rule-based Scoring) ---
			let score = 0;

			// 因子1: 恐慌指数
			if (vix > 20) score += 1;
			if (vix > 30) score += 1; // 叠加

			// 因子2: RSI 超卖
			if (rsi < 40) score += 1;
			if (rsi < 30) score += 1; // 叠加

			// 因子3: 回撤深度
			if (drawdown < -5) score += 1;
			if (drawdown < -15) score += 1; // 叠加

			// --- 3. 执行交易决策 ---

			const isInvested = positions > 0;

			if (!isInvested) {
				// 买入信号: 分数 >= 2 (只要有两个维度的轻度信号，或一个维度的重度信号)
				if (score >= 2) {
					const quantity = cash / price;
					positions = quantity;
					cash = 0;
				}
			} else {
				// 卖出信号:
				// 1. RSI 超买 (>70) -> 即使没创新高也卖
				// 2. 价格修复 (回撤 > -2%) -> 接近前高，获利了结
				// 3. 保护性止损 (可选，暂不加，保持基准简单)
				if (rsi > 70 || drawdown > -2) {
					cash = positions * price;
					positions = 0;
				}
			}

			// --- 4. 记录净值 ---
			const totalValue = cash + (positions * price);
			if (dates.includes(date)) {
				equityCurve.push(totalValue);
			}
		}

		return {
			equityCurve,
			stats: this.calculateMetricsFromCurve(equityCurve, dates)
		};
	}
```

### 4.2 集成到 `runBacktest`

在 `BacktestEngine` 中更新主逻辑：

```typescript
// ... runBacktest 方法内部 ...

// 1. 计算 DCA 基准
const dcaBenchmark = this.calculateWeeklyDCABenchmark(...);

// 2. [新增] 计算 AI Score 基准
const aiBenchmark = this.calculateAIScoreBenchmark(
    filteredData,
    chartData.dates,
    strategy.initialCapital,
    context.vixData // 传入 VIX 数据
);

return {
    // ...
    performance: {
        strategy: performance.strategy,
        benchmark: performance.benchmark, // 买入持有
        dca: dcaBenchmark.stats,          // 周定投
        aiScore: aiBenchmark.stats        // [新增] AI 评分
    },
    charts: {
        // ...
        dcaEquity: dcaBenchmark.equityCurve,
        aiScoreEquity: aiBenchmark.equityCurve, // [新增]
    }
    // ...
};
```

同时，记得更新 `api-dtos.ts` 中的类型定义，增加 `aiScore` 和 `aiScoreEquity` 字段。

---

## 5. 前端展示建议

*   **名称**：**AI 评分模型 (AI Score)**
*   **颜色**：<span style="color:#8B5CF6">**紫色 (Purple)**</span> - 代表智慧、科技。
*   **图表行为预期**：
    *   **买入持有**：一条跟随价格起伏的线。
    *   **AI 评分**：一条**阶梯状**的线。
        *   在牛市主升浪（RSI 高、回撤小）时，它可能是平的（空仓，持有现金）。
        *   在暴跌或回调时，它会突然进场抄底。
        *   反弹后，它会获利离场，净值锁定在高位。

*   **对比价值**：
    *   如果在**震荡市**，AI 评分模型通常会完胜“买入持有”（高抛低吸）。
    *   如果在**单边大牛市**，AI 评分模型可能会跑输（因为它可能卖飞了）。

这能非常直观地教育用户：**“完美的择时是不存在的，每种策略都有适应的市场环境。”**


----


这是对基准 3（AI 评分模型）资金分配逻辑的详细解读：

### 1. 资金限制的核心原则
代码严格遵循以下两条铁律，确保回测真实有效，没有使用杠杆（Margin）：
1.  **不透支**：买入时，只能使用账户里**当前的可用现金 (`cash`)**，不能借钱买入。
2.  **不卖空**：卖出时，只能卖出**当前持有的份额 (`positions`)**。

### 2. 如何分配这 10,000 美元？

在基准 3 的算法中，我们采用了 **“全仓切换 (All-in / All-out)”** 的分配逻辑。这意味着资金在“现金”和“股票”两种状态之间根据 AI 分数进行 100% 的切换。

#### 场景推演 (以初始 10,000 美元为例)：

*   **T+0 (初始)**:
    *   现金: $10,000
    *   持仓: 0
    *   *状态: 空仓观望*

*   **T+10 (发出买入信号)**:
    *   AI 评分 $\ge$ 2，触发买入。
    *   当前股价: $100
    *   **分配逻辑**: 将**所有可用现金**全部买入。
    *   买入数量: $10,000 / 100 = 100$ 股 (假设支持碎股)
    *   现金: $0
    *   持仓: 100 股
    *   *状态: 满仓*

*   **T+50 (发出卖出信号)**:
    *   RSI 超买，触发卖出。
    *   当前股价: $120 (涨了 20%)
    *   **分配逻辑**: 将**所有持仓**全部卖出变成现金。
    *   卖出金额: $100 \times 120 = 12,000$
    *   现金: $12,000 (本金 + 利润)**
    *   持仓: 0
    *   *状态: 空仓止盈*

*   **T+80 (再次发出买入信号)**:
    *   市场大跌，AI 评分再次 $\ge$ 2。
    *   当前股价: $110
    *   **分配逻辑**: 使用**当前所有现金 ($12,000)** 买入。
    *   买入数量: $12,000 / 110 \approx 109.09$ 股
    *   *状态: 满仓 (复利效应生效)*

### 3. 为什么要用“全仓切换”？

您可能会问，为什么不每次只买 10% 或 50%？

1.  **作为基准的纯粹性**：
    基准 3 的目的是测试**“择时能力”**（即：什么时候买，什么时候卖）。采用全仓进出，能最大程度地放大择时的效果。如果择时准，收益会非常高；如果择时差，回撤会很大。这样用户能一眼看出这个“AI 模型”到底聪不聪明。

2.  **资金利用率最大化**：
    如果我们规定“每次只买 $1,000”，那么 1 万本金里有 9 千都在睡觉。这会导致基准的收益率被现金拖累，失去参考价值（就像周定投基准我们要用“完美分配”一样）。

3.  **模拟波段交易 (Swing Trading)**：
    这个基准模仿的是一种典型的波段交易者行为：平时空仓等待，机会（黄金坑）来了重拳出击，赚了就跑。

### 4. 代码逻辑复查

让我们看回 `calculateAIScoreBenchmark` 中的这一段代码，确认它是否符合上述逻辑：

```typescript
			const isInvested = positions > 0;

			if (!isInvested) {
				// 买入信号
				if (score >= 2) {
                    // 逻辑：quantity = 当前所有现金 / 当前价格
					const quantity = cash / price;
					positions = quantity;
					cash = 0; // 现金归零，变为满仓状态
				}
			} else {
				// 卖出信号
				if (rsi > 70 || drawdown > -2) {
                    // 逻辑：现金 = 持仓数量 * 当前价格
					cash = positions * price;
					positions = 0; // 持仓归零，变为空仓状态
				}
			}
```

**结论**：是的，代码逻辑严谨地执行了**“基于当前净值的全仓轮动”**，既没有突破初始资金限制，也完美体现了复利增长（或亏损）的过程。不考虑交易成本是这一阶段合理的简化。
