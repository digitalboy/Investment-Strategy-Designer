

# 基准策略文档：周定投 (Benchmark 2: Weekly DCA)

**版本**: 2.0 (Capital Depletion Edition)
**日期**: 2025-11-25
**模块**: `BacktestEngine` / `BenchmarkService`

## 1. 概述 (Overview)

**周定投 (Weekly DCA)** 是回测系统中的第二基准，用于模拟一个**零择时、完全被动、但资金利用率最大化**的投资策略。

与用户可能设置的“每次固定投 100 元”不同，本基准采用**“资本耗尽模型 (Capital Depletion Model)”**。
*   **目标**：在回测时间段结束时，将初始本金**刚好全部投完**，不留闲置现金。
*   **意义**：这消除了一般定投回测中因“本金未花完”导致的现金拖累（Cash Drag）误差，提供了一个**“如果你把这笔钱平摊到每一周去买”**的公平收益率对比标准。

## 2. 核心算法逻辑

算法分为两个阶段：**预扫描（计算定投额）** 和 **执行（模拟交易）**。

### 2.1 第一阶段：资金分配 (Capital Allocation)
为了保证资金被充分利用，系统必须先知道回测区间一共有多长。

1.  **扫描周期**：遍历回测区间内的所有交易数据。
2.  **统计周数 ($N$)**：计算区间内包含多少个唯一的 ISO 周标识。
3.  **计算周定投额 ($A$)**：
    $$ A = \frac{\text{Initial Capital}}{N} $$

### 2.2 第二阶段：交易执行 (Execution)
在遍历每日数据时，检测“新的一周”信号来触发交易。

*   **交易触发**：
    利用 `Week Identifier`（周标识）检测。只要**当日的周标识与前一日不同**，即判定为本周的第一个交易日（通常为周一，遇节假日自动顺延至周二），立即执行买入。

*   **买入金额 ($Invest$)**：
    *   **常规周**：$Invest = A$
    *   **最后一周/尾差处理**：$Invest = \min(Cash, A)$。
        *注：由于浮点数精度或整除问题，最后一次交易可能会多几分钱或少几分钱，算法将强制用光剩余现金。*

## 3. 边界情况处理 (Edge Cases)

| 场景 | 处理逻辑 | 结果 |
| :--- | :--- | :--- |
| **周一休市** | 数据流中跳过周一，周二的 `WeekID` 发生变化。 | **周二自动买入** (顺延成功) |
| **资金分配不均** | 10000 元分 3 周，除不尽 (3333.33...)。 | 前两周买 3333.33，最后一周买 3333.34 (余额)。 | **资金利用率 100%** |
| **回测时间极短** | 区间内少于 1 周。 | $N=1$，第一天直接买入全部本金。 | 退化为“买入并持有” |

## 4. 代码实现 (TypeScript)

请将此更新后的逻辑集成到 `src/lib/backtest-engine.ts`。

```typescript
	/**
	 * 计算基准2：周定投 (Weekly DCA - Capital Depletion Model)
	 * 逻辑：
	 * 1. 统计回测区间内的总周数。
	 * 2. 将本金平均分配，确保回测结束时本金刚好用完。
	 * 3. 每周第一个交易日买入，遇节假日顺延。
	 */
	private calculateWeeklyDCABenchmark(
		data: ETFDataPoint[],
		dates: string[], // 用于对齐图表的全量日期序列
		initialCapital: number
	): { equityCurve: number[], stats: PerformanceMetrics } {
		
		// --- 阶段 1: 扫描总周数 ---
		const weeksSet = new Set<string>();
		// 预扫描一遍数据，统计有多少个独特的周
		data.forEach(d => weeksSet.add(this.getWeekIdentifier(d.d)));
		const totalWeeks = weeksSet.size;
		
		// 防御性编程：如果数据为空或不足一周
		if (totalWeeks === 0) return this.getEmptyBenchmarkResult();

		// --- 阶段 2: 计算每周应投金额 ---
		// 这确保了资金在时间维度上的完美均匀分布
		const weeklyAmount = initialCapital / totalWeeks;

		// --- 阶段 3: 模拟交易 ---
		let cash = initialCapital;
		let positions = 0;
		let lastWeekId = '';
		const equityCurve: number[] = [];

		// 设置微小阈值处理浮点数比较
		const EPSILON = 0.0001;

		for (const point of data) {
			const currentWeekId = this.getWeekIdentifier(point.d);
			const currentPrice = point.c;

			// 触发条件：
			// 1. 遇到了新的一周 (WeekID 变化)
			// 2. 账户里还有钱 (Cash > 0)
			if (currentWeekId !== lastWeekId && cash > EPSILON) {
				
				// 确定本次买入金额
				// 正常情况下买 weeklyAmount
				// 如果是最后一周或者余额不足一个单位，则 All-in 余额
				let investAmount = weeklyAmount;
				if (cash < weeklyAmount + EPSILON) {
					investAmount = cash;
				}

				// 执行买入 (假设支持碎股交易)
				const quantity = investAmount / currentPrice;
				positions += quantity;
				cash -= investAmount;

				// 强制修正：防止出现极其微小的负数或残留
				if (cash < EPSILON) cash = 0;

				// 更新周标识，防止本周重复买入
				lastWeekId = currentWeekId;
			}

			// 计算当日总资产 (现金 + 持仓市值)
			const totalValue = cash + (positions * currentPrice);
			
			// 数据对齐：只记录在 dates 范围内的点
			if (dates.includes(point.d)) {
				equityCurve.push(totalValue);
			}
		}

		// --- 阶段 4: 生成统计指标 ---
		return {
			equityCurve,
			stats: this.calculateMetricsFromCurve(equityCurve, dates)
		};
	}

    /**
     * 获取 ISO 周标识 (辅助方法)
     */
    private getWeekIdentifier(dateStr: string): string {
        const date = new Date(dateStr);
        date.setHours(0, 0, 0, 0);
        date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);
        const week1 = new Date(date.getFullYear(), 0, 4);
        const weekNumber = 1 + Math.round(((date.getTime() - week1.getTime()) / 86400000 - 3 + (week1.getDay() + 6) % 7) / 7);
        return `${date.getFullYear()}-W${weekNumber.toString().padStart(2, '0')}`;
    }
```

## 5. 为什么选择此逻辑 (Rationale)

**为什么不让用户设定“每周买 100 元”作为基准？**

1.  **公平性问题**：
    如果用户回测 5 年，本金 10000 元。
    *   **固定金额法**：每周买 10 元 -> 5年只投了 2600 元 -> 7400 元现金空转 -> **收益率极低**。
    *   **完美分配法**：每周买 38 元 -> 5年投完 10000 元 -> **收益率真实反映定投效率**。
    
    固定金额法会让基准线显得非常弱（因为现金拖累），导致用户产生“我的策略随便写写都能跑赢基准”的错觉。

2.  **基准的定义**：
    基准（Benchmark）代表的是一种**理想化的、被动的**替代方案。
    “周定投”基准的潜台词是：“如果我一开始就决定把这笔钱分批投进去，并且严格执行，我能赚多少？”
    因此，预先计算 `TotalWeeks` 并倒推 `WeeklyAmount` 是构建这个理想基准的唯一正确方法。

## 6. 前端展示规范

*   **名称**：统一显示为 **“周定投”** (Weekly DCA)。不要加“智能”二字，因为它代表的是一种机械的、无脑的操作。
*   **颜色建议**：建议使用暖色调（如橙色或琥珀色）来区分于策略（蓝色）和大盘（灰色）。
*   **曲线特征**：
    *   在回测初期，曲线会比较平缓（因为仓位低）。
    *   在回测末期，曲线波动会接近大盘。
    *   这直观地向用户展示了定投“平滑波动”的特性。